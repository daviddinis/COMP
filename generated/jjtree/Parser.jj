/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Parser.jj */
/*@egen*/options
{
  LOOKAHEAD= 2;

}

PARSER_BEGIN(parser)
import java.io.*;

public class parser/*@bgen(jjtree)*/implements parserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTparserState jjtree = new JJTparserState();

/*@egen*/
  public static void main(String args []) throws ParseException
  {

    
    parser parser = new parser(System.in);
    parser.Program();
  }

  public static InputStream openFile(String file_path)
  {
    final File file = new File(file_path);
    try
    {
      return new FileInputStream(file);
    }
    catch (FileNotFoundException e)
    {
      System.out.println("This file cannot be opened for reading.");
      return null;
    }
  }
}

PARSER_END(parser)

// Symbols that must be skipped during the lexical analysis
SKIP :
{
  " "
| "\t"
| "\r"
| < "//" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) >
| < "/*" (~[ "*" ])* "*"
    (
      "*"
    | ~[ "*", "/" ] (~[ "*" ])* "*"
    )
    "/" >
}

// token definition (terminal symbols)
TOKEN :
{
  < ADD : "+" >
| < AND : "&&" >
| < BOOLEAN : "boolean" >
| < CLASS : "class" >
| < COMMA : "," >
| < DIV : "/" >
| < DOT : "." >
| < ELSE : "else" >
| < EQUALS : "=" >
| < EXTENDS : "extends" >
| < FALSE : "false" >
| < IF : "if" >
| < IMPORT : "import" >
| < INT : "int" >
| < INTEGERLITERAL : ([ "0"-"9" ])+ >
| < LCURLY : "{" >
| < LENGTH : "length" >
| < LPAR : "(" >
| < LSQUARE : "[" >
| < MAIN : "main" >
| < LESSTHAN : "<" >
| < MUL : "*" >
| < NEW : "new" >
| < NOT : "!" >
| < PUBLIC : "public" >
| < RCURLY : "}" >
| < RETURN : "return" >
| < RPAR : ")" >
| < RSQUARE : "]" >
| < SEMICOLON : ";" >
| < STATIC : "static" >
| < STRING : "String" >
| < SUB : "-" >
| < THIS : "this" >
| < TRUE : "true" >
| < VOID : "void" >
| < WHILE : "while" >
| < IDENTIFIER : [ "A"-"Z", "a"-"z", "_", "$" ] ([ "0"-"9", "A"-"Z", "a"-"z", "_", "$" ])* >
}

SimpleNode Program() : {/*@bgen(jjtree) Program */
  SimpleNode jjtn000 = new SimpleNode(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Program */
  try {
/*@egen*/
  ImportDeclarations() ClassDeclaration() < EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ImportDeclarations()       :
{}
{
  (
    Import()
  )*
}

void Import()       :
{}
{
  < IMPORT > File() < SEMICOLON > // TODO
}

void File()       :
{}
{
  (
    < IDENTIFIER >
  | [ < STATIC > ] < IDENTIFIER > < DOT > < IDENTIFIER > < LPAR > ArgumentImport() < RPAR >
    (
      [ < VOID > ]
    | Type()
    )
  )
}

void ArgumentImport()       :
{}
{
  [
    Type()
    (
      < COMMA > Type()
    )*
  ]
}

void ClassDeclaration()       :
{}
{
  < CLASS > < IDENTIFIER > [ < EXTENDS > < IDENTIFIER > ] < LCURLY > VariableDeclarations() MethodDeclarations() < RCURLY >
}

void VariableDeclarations()       :
{}
{
  (
    Variable()
  )*
}

void Variable()       :
{}
{
  Type() < IDENTIFIER > < SEMICOLON >
}

void MethodDeclarations()       :
{}
{
  (
    GenericMethod()
  )*
}

void GenericMethod()       :
{}
{
  (
    Method()
  | 
    MainMethod()
  )
}

void Method()       :
{}
{
  < PUBLIC > Type() < IDENTIFIER > < LPAR > ArgumentList() < RPAR > 
  < LCURLY > VariableDeclarations() StatementDeclarations() < RETURN > Expression() < SEMICOLON > < RCURLY >
}

void ArgumentList()       :
{}
{
  [
    Argument()
    (
      < COMMA > Argument()
    )*
  ]
}

void Argument()       :
{}
{
  Type() < IDENTIFIER >
}

void MainMethod()       :
{}
{
  < PUBLIC > < STATIC > < VOID > < MAIN > < LPAR > < STRING > < LSQUARE > < RSQUARE > < IDENTIFIER > < RPAR > 
  < LCURLY > VariableDeclarations() StatementDeclarations() < RCURLY >
}

void Type()       :
{}
{
  (
    < INT > < LSQUARE > < RSQUARE >
  | 
    < BOOLEAN >
  | 
    < INT >
  | 
    < IDENTIFIER >
  )
}

void StatementDeclarations()       :
{}
{
  (
    Statement()
  )*
}

void Statement()       :
{}
{
  (
    < LCURLY > StatementDeclarations() < RCURLY >
  | 
    < IF > < LPAR > Expression() < RPAR > Statement() 
    < ELSE > Statement()
  | 
    < WHILE > < LPAR > Expression() < RPAR > Statement()
  | 
    < IDENTIFIER > < EQUALS > Expression() < SEMICOLON >
  | 
    < IDENTIFIER > < LSQUARE > Expression() < RSQUARE > < EQUALS > Expression() < SEMICOLON >
  )
}

void Expression()       :
{}
{
  Term1() < AND > Expression()
}

void Term1()       :
{}
{
  Term2() < LESSTHAN > Expression()
}

void Term2()       :
{}
{
  Term3() < ADD > Expression()
}

void Term3()       :
{}
{
  Term4() < SUB > Expression()
}

void Term4()       :
{}
{
  Term5() < MUL > Expression()
}

void Term5()       :
{}
{
  Term6() < DIV > Expression()
}

void Term6()       :
{}
{
  Term7() < LSQUARE > Expression() < RSQUARE >
}

void Term7()       :
{}
{
  Term8() < DOT > < LENGTH >
}

void Term8()       :
{}
{
  Term9() < DOT > < IDENTIFIER > < LPAR >
  (
    Expression() [ < COMMA > Expression() ]
  )?
  < RPAR >
}

void Term9()       :
{}
{
  (
    < INTEGERLITERAL >
  | 
    < TRUE >
  | 
    < FALSE >
  | 
    < IDENTIFIER >
  | 
    < THIS >
  | 
    < NEW > < INT > < LSQUARE > Expression() < RSQUARE >
  | 
    < NEW > < IDENTIFIER > < LPAR > < RPAR >
  | 
    < NOT > Expression()
  | 
    < LPAR > Expression() < RPAR >
  )
}
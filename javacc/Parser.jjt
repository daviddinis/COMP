options
{
  LOOKAHEAD= 1;
  MULTI=true;
}

PARSER_BEGIN(Parser)

import java.io.FileNotFoundException;
import java.io.*;

public class Parser
{
  static private int errorCount = 10;
  static private int MAX_ERROR_COUNT = 10;

  public static void main(String args []) throws ParseException
  {
    Parser parser;

    errorCount = MAX_ERROR_COUNT;

    if(args.length == 1) {
      try {
		    java.io.FileInputStream file = new java.io.FileInputStream(new java.io.File(args[0]));
	      parser = new Parser(file);
      } catch (FileNotFoundException e) {
        System.out.println(e);
        return;
      }
    } 
    else {
  	  parser = new Parser(System.in);
  	}

    SimpleNode root = parser.Program();
    root.dump("");

    if(errorCount < 10){
      throw new ParseException();
    }
  }
}

PARSER_END(Parser)

JAVACODE
void skipto(int type) {
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != type && t.kind != EOF);
}

JAVACODE
void skipto_dont_consume(int type) {
  Token t;
  int next;
  boolean consume = false;
  do{
	  if(consume){
		  t = getNextToken();
    }
    next = getToken(1).kind;
	  consume = true;
  } while (next != type && next != EOF);
}

JAVACODE
void skip_all(int type) {
  Token t;
  int next;
  boolean consume = false;
  do {
    if (consume) t = getNextToken();
    next = getToken(1).kind;
    consume = true;
  } while(next == type);
}

JAVACODE
void skipto_while_expression() {
  skipto_dont_consume(RPAR);
  skip_all(RPAR);
}

JAVACODE
void printErrorMessage(ParseException e) {
  System.out.println("----- ERROR FOUND -----");
  System.out.println(e.currentToken.next.image + " Line " +
	e.currentToken.beginLine + " Column " +
	e.currentToken.beginColumn);

	System.out.println("EXPECTED TOKENS");

	for(int i = 0; i < e.expectedTokenSequences.length; i++) {
		for(int k = 0; k < e.expectedTokenSequences[i].length; k++) {
			System.out.println(tokenImage[e.expectedTokenSequences[i][k]]);
		}
	}
}

JAVACODE
void whileError(ParseException e) {
  errorCount--;
  printErrorMessage(e);
  if(errorCount == 0) {
    System.out.println("Error exit");
    System.exit(0);
  }
}

// Symbols that must be skipped during the lexical analysis
SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
| < "//" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) >
| < "/*" (~[ "*" ])* "*"
    (
      "*"
    | ~[ "*", "/" ] (~[ "*" ])* "*"
    )*
    "/" >
}

// token definition (terminal symbols)
TOKEN :
{
  < ADD : "+" >
| < AND : "&&" >
| < BOOLEAN : "boolean" >
| < CLASS : "class" >
| < COMMA : "," >
| < DIV : "/" >
| < DOT : "." >
| < ELSE : "else" >
| < EQUALS : "=" >
| < EXTENDS : "extends" >
| < FALSE : "false" >
| < IF : "if" >
| < IMPORT : "import" >
| < INT : "int" >
| < INTEGERLITERAL : (["0"-"9"])+ >
| < LCURLY : "{" >
| < LENGTH : "length" >
| < LPAR : "(" >
| < LSQUARE : "[" >
| < MAIN : "main" >
| < LESSTHAN : "<" >
| < MUL : "*" >
| < NEW : "new" >
| < NOT : "!" >
| < PUBLIC : "public" >
| < RCURLY : "}" >
| < RETURN : "return" >
| < RPAR : ")" >
| < RSQUARE : "]" >
| < SEMICOLON : ";" >
| < STATIC : "static" >
| < STRING : "String" >
| < SUB : "-" >
| < THIS : "this" >
| < TRUE : "true" >
| < VOID : "void" >
| < WHILE : "while" >
| < IDENTIFIER :  ["A"-"Z","a"-"z","$","_"](["0"-"9","A"-"Z","a"-"z","_","$"])* >
}

SimpleNode Program() : {}
{
  ImportDeclarations() ClassDeclaration() <EOF>
  {
    return jjtThis;
  }
}

void ImportDeclarations() #void :
{}
{
  (
    Import()
  )*
}

void Import()  :
{}
{
  < IMPORT > File() < SEMICOLON >
}

void File() #void :
{}
{
  (
    [ < STATIC > #Static ] Identifier() (< DOT > Identifier())* [< LPAR > ArgumentImport() < RPAR >]
    (
      Type() | [ < VOID > #Void ]
    )
  )
}

void ArgumentImport()   :
{}
{
  [
    (Type() | <VOID>)
    (
      < COMMA > (Type() | <VOID>)
    )*
  ]
}

void ClassDeclaration()  :
{}
{
  < CLASS > Identifier() [ < EXTENDS > Identifier()] < LCURLY >  VariableDeclarations() MethodDeclarations() < RCURLY >
}

void VariableDeclarations() #void  :
{}
{
  (
   LOOKAHEAD(2) Variable()
  )*
}

void Variable()  :
{}
{
  Type() Identifier() < SEMICOLON >
}

void MethodDeclarations() #void  :
{}
{
  (
    GenericMethod()
  )*
}

void GenericMethod()  #void :
{}
{
  < PUBLIC >
  (
    Method()
  | 
    MainMethod()
  )
}

void Method()   :
{}
{
  Type() Identifier() < LPAR > ArgumentList() < RPAR > 
  < LCURLY > VariableDeclarations() StatementDeclarations() Return()
}

void Return(): {}
{
  < RETURN > Expression() < SEMICOLON > < RCURLY >
}

void ArgumentList() #void  :
{}
{
  [
    Argument()
    (
      < COMMA > Argument()
    )*
  ]
}

void Argument()  #void :
{}
{
  Type() Identifier()
}

void MainMethod() :
{}
{
  < STATIC > < VOID > < MAIN > < LPAR > < STRING > < LSQUARE > < RSQUARE > Identifier() < RPAR > 
  < LCURLY > VariableDeclarations() StatementDeclarations() < RCURLY >
}

void Type() #void :
{}
{
  (
    LOOKAHEAD(2) < INT > < LSQUARE > < RSQUARE > #IntArray
  | 
    < BOOLEAN > #Bool
  | 
    < INT > #Int
  | 
  Identifier()
  )
}

void StatementDeclarations()  #void :
{}
{
  (
    Statement()
  )*
}

void Statement() #void  :
{}
{ 
    (
      < LCURLY > StatementDeclarations() < RCURLY >
    | 
      If()Then()
      Else()
    | 
      While()
    |
     LOOKAHEAD(2) Equals()
    |
     Expression() <SEMICOLON>
    )

}

void If() : {}
{
  < IF > < LPAR >  Expression() < RPAR > 
}

void Then() :{}
{
  Statement() 
}

void Else() : {}
{
  < ELSE > Statement()
}


void Equals() : {}
{
  Identifier()
    (< LSQUARE > #LSQUARE Expression() < RSQUARE > #RSQUARE < EQUALS > EqualsExpression() < SEMICOLON >
    | < EQUALS > EqualsExpression() < SEMICOLON >)
}

void EqualsExpression() : {}
{
  Expression() 
}

void While()   : {}
{
  try{
    < WHILE > < LPAR > WhileExpression() < RPAR >
  }
  catch(ParseException e) {
    System.out.println("While error detected");
    whileError(e);
    skipto_while_expression();
  }
  Statement()
}

void WhileExpression()  :
{}
{
  Expression()
}

void Expression()  #void :
{}
{
  Term1() ( LOOKAHEAD(2) And() )*
}

void And() : {}
{
  < AND > Term1()
}

void Term1() #void :
{}
{
  Term2() ( LOOKAHEAD(2) LessThan() )* 
}

void LessThan() : {}
{
  < LESSTHAN > Term2()
}

void Term2() #void :
{}
{
  Term3() AddSub()
}

void AddSub() : {}
{
 (LOOKAHEAD(2 )( < ADD > | < SUB > ) Term3() )*
}

void Term3()  #void :
{}
{
  Term6() MulDiv()
}

void MulDiv() : {}
{
  (LOOKAHEAD(2)(  < MUL > | <DIV> ) Term6() ) *
}

void Term6() #void  :
{}
{
  Term7() [ LOOKAHEAD(2) < LSQUARE > #LSQUARE Expression() <RSQUARE> #RSQUARE ]
}

void Term7()#void   :
{}
{
  Term8()  [ LOOKAHEAD(2) < DOT > < LENGTH > #LENGTH ]
}

void Term8()  #void :
{}
{
  Term9()  [ LOOKAHEAD(2) < DOT >  Identifier() < LPAR >
  (
    ArgumentCall()
  )?
  < RPAR >]
}

void ArgumentCall() : {}
{
  Expression() ( < COMMA > #COMMA Expression())*
}

void Term9() #void :
{}
{
  (
    IntLiteral() 
  | 
    < TRUE > #TRUE
  | 
    < FALSE > #FALSE
  | 
    LOOKAHEAD(2) Identifier()
  | 
    < THIS > #THIS
  | 
    LOOKAHEAD(2) NewInt()
  | 
   < NEW > #NEW Identifier() < LPAR > < RPAR > 
  | 
    < NOT > #NOT Expression()
  | 
    Par()
  ) 
}

void IntLiteral() : {Token t;}
{
  t=< INTEGERLITERAL > { jjtThis.jjtSetValue(t.image); }
}

void Identifier() : {Token t;}
{
  t=< IDENTIFIER > { jjtThis.jjtSetValue(t.image); }
}

void NewInt() : {Token t3, t4;}
{
  (< NEW > < INT > t3=< LSQUARE >  Expression() t4=< RSQUARE >) { jjtThis.jjtSetValue(t3.image + t4.image); }
}

void Par(): {}
{
  < LPAR > Expression() < RPAR >
}
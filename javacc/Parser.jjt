options
{
  LOOKAHEAD= 2;

}

PARSER_BEGIN(Parser)

import java.io.FileNotFoundException;
import java.io.*;

public class Parser
{
  static private int errorCount = 10;
  static private int MAX_ERROR_COUNT = 10;

  public static void main(String args []) throws ParseException
  {
    Parser parser;

    errorCount = MAX_ERROR_COUNT;

    if(args.length == 1) {
      try {
		    java.io.FileInputStream file = new java.io.FileInputStream(new java.io.File(args[0]));
	      parser = new Parser(file);
      } catch (FileNotFoundException e) {
        System.out.println(e);
        return;
      }
    } 
    else {
  	  parser = new Parser(System.in);
  	}

    SimpleNode root = parser.Program();
    root.dump("");

    if(errorCount < 10){
      System.out.println("pqp");
      throw new ParseException();
    }
  }
}

PARSER_END(Parser)

JAVACODE
void skipto(int type) {
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != type);
}

JAVACODE
void skipto_dont_consume(int type) {
  Token t;
  int next;
  boolean consume = false;
  do{
	  if(consume){
		  t = getNextToken();
      System.out.println(t.image);
    }
    next = getToken(1).kind;
	  consume = true;
  } while (next != type);
}

JAVACODE
void statementError() {
  errorCount--;
  if(errorCount == 0) {
    System.out.println("Error exit");
    System.exit(0);
  }
}

// Symbols that must be skipped during the lexical analysis
SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
| < "//" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) >
| < "/*" (~[ "*" ])* "*"
    (
      "*"
    | ~[ "*", "/" ] (~[ "*" ])* "*"
    )*
    "/" >
}

// token definition (terminal symbols)
TOKEN :
{
  < ADD : "+" >
| < AND : "&&" >
| < BOOLEAN : "boolean" >
| < CLASS : "class" >
| < COMMA : "," >
| < DIV : "/" >
| < DOT : "." >
| < ELSE : "else" >
| < EQUALS : "=" >
| < EXTENDS : "extends" >
| < FALSE : "false" >
| < IF : "if" >
| < IMPORT : "import" >
| < INT : "int" >
| < INTEGERLITERAL : (["0"-"9"])+ >
| < LCURLY : "{" >
| < LENGTH : "length" >
| < LPAR : "(" >
| < LSQUARE : "[" >
| < MAIN : "main" >
| < LESSTHAN : "<" >
| < MUL : "*" >
| < NEW : "new" >
| < NOT : "!" >
| < PUBLIC : "public" >
| < RCURLY : "}" >
| < RETURN : "return" >
| < RPAR : ")" >
| < RSQUARE : "]" >
| < SEMICOLON : ";" >
| < STATIC : "static" >
| < STRING : "String" >
| < SUB : "-" >
| < THIS : "this" >
| < TRUE : "true" >
| < VOID : "void" >
| < WHILE : "while" >
| < IDENTIFIER :  ["A"-"Z","a"-"z","$","_"](["0"-"9","A"-"Z","a"-"z","_","$"])* >
}

SimpleNode Program() : {}
{
  ImportDeclarations() ClassDeclaration() <EOF>
  {
    return jjtThis;
  }
}

void ImportDeclarations()  :
{}
{
  (
    Import()
  )*
}

void Import() :
{}
{
  < IMPORT > File() < SEMICOLON >
}

void File() :
{}
{
  (
    [ < STATIC > ] < IDENTIFIER > < DOT > < IDENTIFIER > < LPAR > ArgumentImport() < RPAR >
    (
      Type() | [ < VOID > ]
    )
    |< IDENTIFIER >
    
  )
}

void ArgumentImport()  :
{}
{
  [
    (Type() | <VOID>)
    (
      < COMMA > (Type() | <VOID>)
    )*
  ]
}

void ClassDeclaration()   :
{}
{
  < CLASS > < IDENTIFIER > [ < EXTENDS > < IDENTIFIER > ] < LCURLY > VariableDeclarations() MethodDeclarations() < RCURLY >
}

void VariableDeclarations()   :
{}
{
  (
    Variable()
  )*
}

void Variable()   :
{}
{
  Type() < IDENTIFIER > < SEMICOLON >
}

void MethodDeclarations()   :
{}
{
  (
    GenericMethod()
  )*
}

void GenericMethod()   :
{}
{
  (
    Method()
  | 
    MainMethod()
  )
}

void Method()   :
{}
{
  < PUBLIC > Type() < IDENTIFIER > < LPAR > ArgumentList() < RPAR > 
  < LCURLY > VariableDeclarations() StatementDeclarations() < RETURN > Expression() < SEMICOLON > < RCURLY >
}

void ArgumentList()   :
{}
{
  [
    Argument()
    (
      < COMMA > Argument()
    )*
  ]
}

void Argument()   :
{}
{
  Type() < IDENTIFIER >
}

void MainMethod()   :
{}
{
  < PUBLIC > < STATIC > < VOID > < MAIN > < LPAR > < STRING > < LSQUARE > < RSQUARE > < IDENTIFIER > < RPAR > 
  < LCURLY > VariableDeclarations() StatementDeclarations() < RCURLY >
}

void Type()   :
{}
{
  (
    < INT > < LSQUARE > < RSQUARE >
  | 
    < BOOLEAN >
  | 
    < INT >
  | 
    < IDENTIFIER >
  )
}

void StatementDeclarations()   :
{}
{
  (
    Statement()
  )*
}

void Statement()   :
{}
{
    (
      < LCURLY > StatementDeclarations() < RCURLY >
    | 
      < IF > < LPAR > Expression() < RPAR > Statement() 
      < ELSE > Statement()
    | 
      While()
    |
      < IDENTIFIER > < LSQUARE > Expression() < RSQUARE > < EQUALS > Expression() < SEMICOLON >
    |
    < IDENTIFIER > < EQUALS > Expression() < SEMICOLON >
    |
    Expression() <SEMICOLON>
    )

}

void While()   : {}
{
  try{
    < WHILE > < LPAR > Expression() < RPAR >
  }
  catch(ParseException e) {
    System.out.println("While error detected");
    statementError();
    skipto_dont_consume(LCURLY);
  }
  Statement()
}

void Expression()   :
{}
{
  Term1() [ < AND > Expression() ]
}

void Term1()   :
{}
{
  Term2() [ < LESSTHAN > Expression() ]
}

void Term2()   :
{}
{
  Term3() [ < ADD > Expression() ]
}

void Term3()   :
{}
{
  Term4() [ < SUB > Expression() ]
}

void Term4()   :
{}
{
  Term5() [ < MUL > Expression() ]
}

void Term5()   :
{}
{
  Term6() [ < DIV > Expression() ]
}

void Term6()   :
{}
{
  Term7() [ < LSQUARE > Expression() < RSQUARE > ]
}

void Term7()   :
{}
{
  Term8() [ < DOT > < LENGTH > ]
}

void Term8()   :
{}
{
  Term9()  [ < DOT > < IDENTIFIER > < LPAR >
  (
    Expression() ( < COMMA > Expression())*
  )?
  < RPAR > ]
}

void Term9()   :
{}
{
  (
    < INTEGERLITERAL >
  | 
    < TRUE >
  | 
    < FALSE >
  | 
    < IDENTIFIER >
  | 
    < THIS >
  | 
    < NEW > < INT > < LSQUARE > Expression() < RSQUARE >
  | 
    < NEW > < IDENTIFIER > < LPAR > < RPAR >
  | 
    < NOT > Expression()
  | 
    < LPAR > Expression() < RPAR >
  )
}

options
{
  LOOKAHEAD= 2;

}

PARSER_BEGIN(Parser)

import java.io.FileNotFoundException;
import java.io.*;

public class Parser
{
  static private int errorCount = 10;

  public static void main(String args []) throws ParseException
  {
    Parser parser;
    
    if(args.length == 1) {
      try {
		    java.io.FileInputStream file = new java.io.FileInputStream(new java.io.File(args[0]));
	      parser = new Parser(file);
      } catch (FileNotFoundException e) {
        System.out.println(e);
        return;
      }
    } 
    else {
  	  parser = new Parser(System.in);
  	}

	  SimpleNode root = parser.Program();
    errorCount = 10;
  }
}

PARSER_END(Parser)

JAVACODE
void skipto(int type) {
  ParseException e = generateParseException();
  System.out.println(e.toString());
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != type);
}

JAVACODE
void skipto_dont_consume(int type) {
  ParseException e = generateParseException();
  System.out.println(e.toString());
  Token t;
  int next;
  boolean consume = false;
  do{
	  if(consume)
		  t = getNextToken();
	  next = getToken(0).kind;
	  consume = true;
  } while (next != type);
}

JAVACODE
void statementError() {
  ParseException e = generateParseException();
  System.out.println(e.toString());
  errorCount--;
  if(errorCount == 0) {
    System.exit(0);
  }
}

// Symbols that must be skipped during the lexical analysis
SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
| < "//" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) >
| < "/*" (~[ "*" ])* "*"
    (
      "*"
    | ~[ "*", "/" ] (~[ "*" ])* "*"
    )
    "/" >
}

// token definition (terminal symbols)
TOKEN :
{
  < ADD : "+" >
| < AND : "&&" >
| < BOOLEAN : "boolean" >
| < CLASS : "class" >
| < COMMA : "," >
| < DIV : "/" >
| < DOT : "." >
| < ELSE : "else" >
| < EQUALS : "=" >
| < EXTENDS : "extends" >
| < FALSE : "false" >
| < IF : "if" >
| < IMPORT : "import" >
| < INT : "int" >
| < INTEGERLITERAL : (["0"-"9"])+ >
| < LCURLY : "{" >
| < LENGTH : "length" >
| < LPAR : "(" >
| < LSQUARE : "[" >
| < MAIN : "main" >
| < LESSTHAN : "<" >
| < MUL : "*" >
| < NEW : "new" >
| < NOT : "!" >
| < PUBLIC : "public" >
| < RCURLY : "}" >
| < RETURN : "return" >
| < RPAR : ")" >
| < RSQUARE : "]" >
| < SEMICOLON : ";" >
| < STATIC : "static" >
| < STRING : "String" >
| < SUB : "-" >
| < THIS : "this" >
| < TRUE : "true" >
| < VOID : "void" >
| < WHILE : "while" >
| < IDENTIFIER :  ["A"-"Z","a"-"z","$","_"](["0"-"9","A"-"Z","a"-"z","_","$"])* >
}

SimpleNode Program() : {}
{
  ImportDeclarations() ClassDeclaration() < EOF >
  {
    return jjtThis;
  }
}

void ImportDeclarations() #void :
{}
{
  (
    Import()
  )*
}

void Import() #void :
{}
{
  < IMPORT > File() < SEMICOLON >
}

void File() #void :
{}
{
  (
    < IDENTIFIER >
  | [ < STATIC > ] < IDENTIFIER > < DOT > < IDENTIFIER > < LPAR > ArgumentImport() < RPAR >
    (
      [ < VOID > ]
    | Type()
    )
  )
}

void ArgumentImport() #void :
{}
{
  [
    Type()
    (
      < COMMA > Type()
    )*
  ]
}

void ClassDeclaration() #void :
{}
{
  < CLASS > < IDENTIFIER > [ < EXTENDS > < IDENTIFIER > ] < LCURLY > VariableDeclarations() MethodDeclarations() < RCURLY >
}

void VariableDeclarations() #void :
{}
{
  (
    Variable()
  )*
}

void Variable() #void :
{}
{
  Type() < IDENTIFIER > < SEMICOLON >
}

void MethodDeclarations() #void :
{}
{
  (
    GenericMethod()
  )*
}

void GenericMethod() #void :
{}
{
  (
    Method()
  | 
    MainMethod()
  )
}

void Method() #void :
{}
{
  < PUBLIC > Type() < IDENTIFIER > < LPAR > ArgumentList() < RPAR > 
  < LCURLY > VariableDeclarations() StatementDeclarations() < RETURN > Expression() < SEMICOLON > < RCURLY >
}

void ArgumentList() #void :
{}
{
  [
    Argument()
    (
      < COMMA > Argument()
    )*
  ]
}

void Argument() #void :
{}
{
  Type() < IDENTIFIER >
}

void MainMethod() #void :
{}
{
  < PUBLIC > < STATIC > < VOID > < MAIN > < LPAR > < STRING > < LSQUARE > < RSQUARE > < IDENTIFIER > < RPAR > 
  < LCURLY > VariableDeclarations() StatementDeclarations() < RCURLY >
}

void Type() #void :
{}
{
  (
    < INT > < LSQUARE > < RSQUARE >
  | 
    < BOOLEAN >
  | 
    < INT >
  | 
    < IDENTIFIER >
  )
}

void StatementDeclarations() #void :
{}
{
  (
    Statement()
  )*
}

void Statement() #void :
{}
{
  try {
    (
      < LCURLY > StatementDeclarations() < RCURLY >
    | 
      < IF > < LPAR > Expression() < RPAR > Statement() 
      < ELSE > Statement()
    | 
      While()
    | 
      < IDENTIFIER > < EQUALS > Expression() < SEMICOLON >
    | 
      < IDENTIFIER > < LSQUARE > Expression() < RSQUARE > < EQUALS > Expression() < SEMICOLON >
    )
  }
  catch(ParseException e) {
     statementError();
  }
}

void While() #void : {}
{
  try{
    < WHILE > < LPAR > Expression() < RPAR >
  }
  catch(ParseException e) {
    System.out.println("While error detected");
    skipto_dont_consume(LCURLY);
  }
  Statement()
}

void Expression() #void :
{}
{
  Term1() [ < AND > Expression() ]
}

void Term1() #void :
{}
{
  Term2() [ < LESSTHAN > Expression() ]
}

void Term2() #void :
{}
{
  Term3() [ < ADD > Expression() ]
}

void Term3() #void :
{}
{
  Term4() [ < SUB > Expression() ]
}

void Term4() #void :
{}
{
  Term5() [ < MUL > Expression() ]
}

void Term5() #void :
{}
{
  Term6() [ < DIV > Expression() ]
}

void Term6() #void :
{}
{
  Term7() [ < LSQUARE > Expression() < RSQUARE > ]
}

void Term7() #void :
{}
{
  Term8() [ < DOT > < LENGTH > ]
}

void Term8() #void :
{}
{
  Term9()  [ < DOT > < IDENTIFIER > < LPAR >
  (
    Expression() [ < COMMA > Expression() ]
  )?
  < RPAR > ]
}

void Term9() #void :
{}
{
  (
    < INTEGERLITERAL >
  | 
    < TRUE >
  | 
    < FALSE >
  | 
    < IDENTIFIER >
  | 
    < THIS >
  | 
    < NEW > < INT > < LSQUARE > Expression() < RSQUARE >
  | 
    < NEW > < IDENTIFIER > < LPAR > < RPAR >
  | 
    < NOT > Expression()
  | 
    < LPAR > Expression() < RPAR >
  )
}

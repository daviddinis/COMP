options
{
  LOOKAHEAD= 2;

}

PARSER_BEGIN(Parser)

import java.io.FileNotFoundException;
import java.io.*;

public class Parser
{
  static private int errorCount = 10;
  static private int MAX_ERROR_COUNT = 10;

  public static void main(String args []) throws ParseException
  {
    Parser parser;

    errorCount = MAX_ERROR_COUNT;

    if(args.length == 1) {
      try {
		    java.io.FileInputStream file = new java.io.FileInputStream(new java.io.File(args[0]));
	      parser = new Parser(file);
      } catch (FileNotFoundException e) {
        System.out.println(e);
        return;
      }
    } 
    else {
  	  parser = new Parser(System.in);
  	}

    SimpleNode root = parser.Program();
    root.dump("");

    if(errorCount < 10){
      throw new ParseException();
    }
  }
}

PARSER_END(Parser)

JAVACODE
void skipto(int type) {
  Token t;
  do {
    t = getNextToken();
  } while (t.kind != type);
}

JAVACODE
void skipto_dont_consume(int type) {
  Token t;
  int next;
  boolean consume = false;
  do{
	  if(consume){
		  t = getNextToken();
      System.out.println(t.image);
    }
    next = getToken(1).kind;
	  consume = true;
  } while (next != type && next != EOF);
}

JAVACODE
void statementError() {
  errorCount--;
  if(errorCount == 0) {
    System.out.println("Error exit");
    System.exit(0);
  }
}

// Symbols that must be skipped during the lexical analysis
SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
| < "//" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) >
| < "/*" (~[ "*" ])* "*"
    (
      "*"
    | ~[ "*", "/" ] (~[ "*" ])* "*"
    )*
    "/" >
}

// token definition (terminal symbols)
TOKEN :
{
  < ADD : "+" >
| < AND : "&&" >
| < BOOLEAN : "boolean" >
| < CLASS : "class" >
| < COMMA : "," >
| < DIV : "/" >
| < DOT : "." >
| < ELSE : "else" >
| < EQUALS : "=" >
| < EXTENDS : "extends" >
| < FALSE : "false" >
| < IF : "if" >
| < IMPORT : "import" >
| < INT : "int" >
| < INTEGERLITERAL : (["0"-"9"])+ >
| < LCURLY : "{" >
| < LENGTH : "length" >
| < LPAR : "(" >
| < LSQUARE : "[" >
| < MAIN : "main" >
| < LESSTHAN : "<" >
| < MUL : "*" >
| < NEW : "new" >
| < NOT : "!" >
| < PUBLIC : "public" >
| < RCURLY : "}" >
| < RETURN : "return" >
| < RPAR : ")" >
| < RSQUARE : "]" >
| < SEMICOLON : ";" >
| < STATIC : "static" >
| < STRING : "String" >
| < SUB : "-" >
| < THIS : "this" >
| < TRUE : "true" >
| < VOID : "void" >
| < WHILE : "while" >
| < IDENTIFIER :  ["A"-"Z","a"-"z","$","_"](["0"-"9","A"-"Z","a"-"z","_","$"])* >
}

SimpleNode Program() : {}
{
  ImportDeclarations() ClassDeclaration() <EOF>
  {
    return jjtThis;
  }
}

void ImportDeclarations() #void :
{}
{
  (
    Import()
  )*
}

void Import()  :
{}
{
  < IMPORT > File() < SEMICOLON >
}

void File() #void :
{}
{
  (
    [ < STATIC > #Static ] Identifier() < DOT > Identifier() < LPAR > ArgumentImport() < RPAR >
    (
      Type() | [ < VOID > #Void ]
    )
    |Identifier()
    
  )
}

void ArgumentImport()   :
{}
{
  [
    (Type() | <VOID>)
    (
      < COMMA > (Type() | <VOID>)
    )*
  ]
}

void ClassDeclaration()  :
{}
{
  < CLASS > Identifier() [ < EXTENDS > Identifier()] < LCURLY > VariableDeclarations() MethodDeclarations() < RCURLY >
}

void VariableDeclarations() #void  :
{}
{
  (
    Variable()
  )*
}

void Variable()  :
{}
{
  Type() Identifier() < SEMICOLON >
}

void MethodDeclarations() #void  :
{}
{
  (
    GenericMethod()
  )*
}

void GenericMethod()  #void :
{}
{
  (
    Method()
  | 
    MainMethod()
  )
}

void Method()   :
{}
{
  < PUBLIC > Type() Identifier() < LPAR > ArgumentList() < RPAR > 
  < LCURLY > VariableDeclarations() StatementDeclarations() < RETURN > Expression() < SEMICOLON > < RCURLY >
}

void ArgumentList() #void  :
{}
{
  [
    Argument()
    (
      < COMMA > Argument()
    )*
  ]
}

void Argument()  #void :
{}
{
  Type() Identifier()
}

void MainMethod() :
{}
{
  < PUBLIC > < STATIC > < VOID > < MAIN > < LPAR > < STRING > < LSQUARE > < RSQUARE > Identifier() < RPAR > 
  < LCURLY > VariableDeclarations() StatementDeclarations() < RCURLY >
}

void Type() #void :
{}
{
  (
    < INT > < LSQUARE > < RSQUARE > #IntArray
  | 
    < BOOLEAN > #Bool
  | 
    < INT > #Int
  | 
  Identifier()
  )
}

void StatementDeclarations()  #void :
{}
{
  (
    Statement()
  )*
}

void Statement() #void  :
{}
{
    (
      < LCURLY > StatementDeclarations() < RCURLY >
    | 
      If()Then()
      Else()
    | 
      While()
    |
      Equals()
    |
    Expression() <SEMICOLON>
    )

}

void If() : {}
{
  < IF > < LPAR >  Expression() < RPAR > 
}

void Then() :{}
{
  Statement() 
}

void Else() : {}
{
  < ELSE > Statement()
}


void Equals() : {}
{
  Identifier() < LSQUARE > #LSQUARE Expression() < RSQUARE > #RSQUARE < EQUALS > EqualsExpression() < SEMICOLON >
  |Identifier() < EQUALS > EqualsExpression() < SEMICOLON >
}

void EqualsExpression() : {}
{
  Expression() 
}

void While()   : {}
{
  try{
    < WHILE > < LPAR > WhileExpression() < RPAR >
  }
  catch(ParseException e) {
    System.out.println("While error detected");
    statementError();
    skipto_dont_consume(LCURLY);
  }
  Statement()
}

void WhileExpression()  :
{}
{
  Expression()
}

void Expression()  #void :
{}
{
  Term1() [ < AND > #AND Expression() ] 
}

void Term1()  #void :
{}
{
  Term2() [ < LESSTHAN > #LESSTHAN Expression() ] 
}

void Term2()  #void :
{}
{
  Term3() [ < ADD > #ADD Expression() ]
}

void Term3()  #void :
{}
{
  Term4() [ < SUB > #SUB Expression() ]
}

void Term4()  #void :
{}
{
  Term5() [ < MUL > #MUL Expression() ]
}

void Term5() #void  :
{}
{
  Term6() [ < DIV > #DIV Expression() ]
}

void Term6() #void  :
{}
{
  Term7() [ < LSQUARE > #LSQUARE Expression() <RSQUARE> #RSQUARE ]
}

void Term7()#void   :
{}
{
  Term8() [ < DOT > < LENGTH > #LENGTH ]
}

void Term8()  #void :
{}
{
  Term9()  [ < DOT >  Identifier() < LPAR >
  (
    ArgumentCall()
  )?
  < RPAR >]
}

void ArgumentCall() : {}
{
  Expression() ( < COMMA > #COMMA Expression())*
}

void Term9() #void :
{}
{
  (
    IntLiteral() 
  | 
    < TRUE > #TRUE
  | 
    < FALSE > #FALSE
  | 
    Identifier()
  | 
    < THIS > #THIS
  | 
     NewInt()
  | 
    < NEW > #NEW Identifier() < LPAR > < RPAR > 
  | 
    < NOT > #NOT Expression()
  | 
    < LPAR >  Expression() < RPAR >
  )
}

void IntLiteral() : {Token t;}
{
  t=< INTEGERLITERAL > { jjtThis.jjtSetValue(t.image); }
}

void Identifier() : {Token t;}
{
  t=< IDENTIFIER > { jjtThis.jjtSetValue(t.image); }
}

void NewInt() : {Token t3, t4;}
{
  (< NEW > < INT > t3=< LSQUARE >  Expression() t4=< RSQUARE >) { jjtThis.jjtSetValue(t3.image + t4.image); }
}
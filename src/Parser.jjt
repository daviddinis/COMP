options {
LOOKAHEAD = 2;
}

PARSER_BEGIN(parser)

public class parser{
	public static void main(String args[]) throws ParseException{
		parser parser = new parser(System.in);
		parser.Program();
	}
}

PARSER_END(parser)

// Symbols that must be skipped during the lexical analysis
SKIP :
{
	" " | "\t" | "\r"
}

// token definition (terminal symbols)
TOKEN :
{
	  < ADD: "+" >
	| < AND: "&&" >
	| < BOOLEAN: "boolean" >
	| < CLASS : "class" >
	| < COMMA: "," >
	| < DIV: "/" >
	| < DOT: "." >
	| < ELSE: "else" >
	| < EQUALS: "=" >
	| < EXTENDS: "extends" >
	| < FALSE: "false" >
	| < IDENTIFIER: ["A"-"Z","a"-"z","_","$"](["0"-"9","A"-"Z","a"-"z","_","$"])* >
	| < IF: "if" >
	| < IMPORT : "import" >
	| < INT: "int" >
	| < INTEGERLITERAL: "" >
	| < LCURLY: "{" >
	| < LENGTH: "length" >
	| < LPAR: "(" >
	| < LSQUARE: "[" >
	| < MAIN: "main" >
	| < LESSTHAN: "<" >
	| < MUL: "*" >
	| < NEW: "new" >
	| < NOT: "!" >
	| < PUBLIC: "public">
	| < RCURLY: "}" >
	| < RETURN: "return" >
	| < RPAR: ")" >
	| < RSQUARE: "]" >
	| < SEMICOLON : ";" >
	| < STATIC: "static" >
	| < STRING: "String" >
	| < SUB: "-" >
	| < THIS: "this" >
	| < TRUE: "true" >
	| < VOID: "void" >
	| < WHILE: "while" >
}


void Program() #void : {}
{
  ImportDeclarations() ClassDeclarations() EOF
}

void ImportDeclarations() #void : {}
{
	(Import())*
}

void Import() #void : {}
{
  <IMPORT> File() <SEMICOLON> // TODO
}

void Class() #void : {}
{
  <CLASS> <IDENTIFIER> [ <EXTENDS> <IDENTIFIER> ] <LCURLY> VariableDeclarations() MethodDeclarations() <RCURLY>
}

void VariableDeclarations() #void : {}
{
	(Variable())*
}

void Variable() #void : {}
{
  Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclarations() #void : {}
{
	(GenericMethod())*
}

void GenericMethod() #void : {}
{
  (
    Method()
  |
    MainMethod()
  )
}

void Method() #void : {}
{
	<PUBLIC> Type() <IDENTIFIER> <LPAR> ArgumentList() <RPAR>
    <LCURLY> VariableDeclarations() StatementDeclarations() <RETURN> Expression() <SEMICOLON> <RCURLY>
}

void ArgumentList() #void : {}
{
	[Argument() (<COMMA> Argument())* ]
}

void Argument() #void : {}
{
	Type() <IDENTIFIER>
}

void MainMethod() #void : {}
{
	<PUBLIC> <STATIC> <VOID> <MAIN> <LPAR> <STRING> <LSQUARE> <RSQUARE> <IDENTIFIER> <RPAR>
    <LCURLY> VariableDeclarations() StatementDeclarations() <RCURLY>
}

void Type() #void : {}
{
  (
    <INT> <LSQUARE> <RSQUARE>
  |
    <BOOLEAN>
  |
    <INT>
  |
    <IDENTIFIER>
  )
}

void StatementDeclarations() #void : {}
{
	(Statement())*
}

void Statement() #void : {}
{
  (
    <LCURLY> StatementDeclarations() <RCURLY>
  |
    <IF> <LPAR> Expression() <RPAR> Statement()
    <ELSE> Statement()
  |
    <WHILE> <LPAR> Expression() <RPAR> Statement()
  |
    <IDENTIFIER> <EQUALS> Expression() <SEMICOLON>
  |
    <IDENTIFIER> <LSQUARE> Expression <RSQUARE> <EQUALS> Expression() <SEMICOLON>
  )
}

void Expression() #void : {}
{
  (
    Expression() <AND> Expression()
  |
  	Expression() <LESSTHAN> Expression()
  |
  	Expression() <ADD> Expression()
  |
  	Expression() <SUB> Expression()
  |
  	Expression() <MUL> Expression()
  |
  	Expression() <DIV> Expression()
  |
    Expression() <LSQUARE> Expression() <RSQUARE>
  |
    Expression() <DOT> <LENGTH>
  |
    Expression() <DOT> Identifier <LPAR> ( Expression() [ <COMMA> Expression ] )? <RPAR>
  |
    <INTEGERLITERAL>
  | 
    <TRUE>
  | 
    <FALSE>
  |
    <IDENTIFIER>
  |
    <THIS>
  |
    <NEW> <INT> <LSQUARE> Expression() <RSQUARE>
  |
    <NEW> <IDENTIFIER> <LPAR> <RPAR>
  |
    <NOT> Expression()
  |
    <LPAR> Expression() <RPAR>
  )
}

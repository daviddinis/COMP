options {
LOOKAHEAD = 2;
}

PARSER_BEGIN(parser)

public class parser{
	public static void main(String args[]) throws ParseException{
		parser parser = new parser(System.in);
		parser.Program();
	}

	public static InputStream openFile(String file_path) {
        final File file = new File(file_path);
        try {
            return new FileInputStream(file);
        } catch(FileNotFoundException e) {
            System.out.println("This file cannot be opened for reading.");
            return null;
        }
    }
	
}

PARSER_END(parser)

// Symbols that must be skipped during the lexical analysis
SKIP :
{
	" " | "\t" | "\r"
	| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
    | <"/" (~[""])* "" ("" | ~["","/"] (~[""])* "") "/">
}

// token definition (terminal symbols)
TOKEN :
{
	  < ADD: "+" >
	| < AND: "&&" >
	| < BOOLEAN: "boolean" >
	| < CLASS : "class" >
	| < COMMA: "," >
	| < DIV: "/" >
	| < DOT: "." >
	| < ELSE: "else" >
	| < EQUALS: "=" >
	| < EXTENDS: "extends" >
	| < FALSE: "false" >
	| < IF: "if" >
	| < IMPORT : "import" >
	| < INT: "int" >
	| < INTEGERLITERAL: (["0"-"9"])+ >
	| < LCURLY: "{" >
	| < LENGTH: "length" >
	| < LPAR: "(" >
	| < LSQUARE: "[" >
	| < MAIN: "main" >
	| < LESSTHAN: "<" >
	| < MUL: "*" >
	| < NEW: "new" >
	| < NOT: "!" >
	| < PUBLIC: "public">
	| < RCURLY: "}" >
	| < RETURN: "return" >
	| < RPAR: ")" >
	| < RSQUARE: "]" >
	| < SEMICOLON : ";" >
	| < STATIC: "static" >
	| < STRING: "String" >
	| < SUB: "-" >
	| < THIS: "this" >
	| < TRUE: "true" >
	| < VOID: "void" >
	| < WHILE: "while" >
	| < IDENTIFIER: ["A"-"Z","a"-"z","_","$"](["0"-"9","A"-"Z","a"-"z","_","$"])* >
}


void Program() #void : {}
{
  ImportDeclarations() ClassDeclaration() <EOF>
}

void ImportDeclarations() #void : {}
{
	(Import())*
}

void Import() #void : {}
{
  <IMPORT> File() <SEMICOLON> // TODO
}

void File() #void: {}
{
	(
	 <IDENTIFIER>
	|[<STATIC>] <IDENTIFIER> <DOT> <IDENTIFIER> <LPAR> ArgumentImport() <RPAR> ([<VOID>]| Type())
	)
}

void ArgumentImport() #void : { }
{
	[Type() (<COMMA> Type())* ]
}


void ClassDeclaration() #void : {}
{
  <CLASS> <IDENTIFIER> [ <EXTENDS> <IDENTIFIER> ] <LCURLY> VariableDeclarations() MethodDeclarations() <RCURLY>
}

void VariableDeclarations() #void : {}
{
	(Variable())*
}

void Variable() #void : {}
{
  Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclarations() #void : {}
{
	(GenericMethod())*
}

void GenericMethod() #void : {}
{
  (
    Method()
  |
    MainMethod()
  )
}

void Method() #void : {}
{
	<PUBLIC> Type() <IDENTIFIER> <LPAR> ArgumentList() <RPAR>
    <LCURLY> VariableDeclarations() StatementDeclarations() <RETURN> Expression() <SEMICOLON> <RCURLY>
}

void ArgumentList() #void : {}
{
	[Argument() (<COMMA> Argument())* ]
}

void Argument() #void : {}
{
	Type() <IDENTIFIER>
}

void MainMethod() #void : {}
{
	<PUBLIC> <STATIC> <VOID> <MAIN> <LPAR> <STRING> <LSQUARE> <RSQUARE> <IDENTIFIER> <RPAR>
    <LCURLY> VariableDeclarations() StatementDeclarations() <RCURLY>
}

void Type() #void : {}
{
  (
    <INT> <LSQUARE> <RSQUARE>
  |
    <BOOLEAN>
  |
    <INT>
  |
    <IDENTIFIER>
  )
}

void StatementDeclarations() #void : {}
{
	(Statement())*
}

void Statement() #void : {}
{
  (
    <LCURLY> StatementDeclarations() <RCURLY>
  |
    <IF> <LPAR> Expression() <RPAR> Statement()
    <ELSE> Statement()
  |
    <WHILE> <LPAR> Expression() <RPAR> Statement()
  |
    <IDENTIFIER> <EQUALS> Expression() <SEMICOLON>
  |
    <IDENTIFIER> <LSQUARE> Expression() <RSQUARE> <EQUALS> Expression() <SEMICOLON>
  )
}

void Expression() #void : {}
{
    Term1() <AND> Expression()
 }

void Term1() #void : {}
{
  Term2() <LESSTHAN> Expression()
}

void Term2() #void : { }
{
  Term3() <ADD> Expression()
}

void Term3() #void : { }
{
  	Term4() <SUB> Expression()
}

void Term4() #void : { }
{
  	Term5() <MUL> Expression()
}

void Term5() #void : { }
{
  	Term6() <DIV> Expression()
}

void Term6() #void : { }
{
    Term7() <LSQUARE> Expression() <RSQUARE>
}

void Term7() #void : { }
{
    Term8() <DOT> <LENGTH>
}

void Term8() #void : { }
{
    Term9() <DOT> <IDENTIFIER> <LPAR> ( Expression() [ <COMMA> Expression() ] )? <RPAR>
}

void Term9() #void : { }
{
  (
    <INTEGERLITERAL>
  | 
    <TRUE>
  | 
    <FALSE>
  |
    <IDENTIFIER>
  |
    <THIS>
  |
    <NEW> <INT> <LSQUARE> Expression() <RSQUARE>
  |
    <NEW> <IDENTIFIER> <LPAR> <RPAR>
  |
    <NOT> Expression()
  |
    <LPAR> Expression() <RPAR>
    )
}
